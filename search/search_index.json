{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"reconciler","text":"<p><code>reconciler</code> is a python package to reconcile tabular data with various reconciliation services, such as  Wikidata, working similarly to what OpenRefine  does, but entirely within Python, using Pandas.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>You can install the latest version of reconciler from PyPI with:</p> <pre><code>pip install reconciler\n</code></pre> <p>Then to use it:</p> <pre><code>from reconciler import reconcile\nimport pandas as pd\n\n# A DataFrame with a column you want to reconcile.\ntest_df = pd.DataFrame(\n    {\n        \"City\": [\"Rio de Janeiro\", \"S\u00e3o Paulo\", \"S\u00e3o Paulo\", \"Natal\"],\n        \"Country\": [\"Q155\", \"Q155\", \"Q155\", \"Q155\"]\n    }\n)\n\n# Reconcile against type city (Q515), getting the best match for each item.\nreconciled = reconcile(test_df[\"City\"], type_id=\"Q515\")\n</code></pre> <p>The resulting dataframe would look like this:</p> id match name score type type_id input_value Q8678 True Rio de Janeiro 100 city Q515 Rio de Janeiro Q174 True S\u00e3o Paulo 100 city Q515 S\u00e3o Paulo Q131620 True Natal 100 municipality of Brazil Q3184121 Natal <p>In case you want to ensure the results are cities from Brazil, you can specify the property_mapping argument with a specific property-value pair:</p> <pre><code># Reconcile against type city (Q515) and items have the country (P17) property equals to Brazil (Q155)\nreconciled = reconcile(test_df[\"City\"], type_id=\"Q515\", property_mapping={\"P17\": test_df[\"Country\"]})\n</code></pre>"},{"location":"#options","title":"Options","text":"<p>The <code>reconcile()</code> function accepts several options.</p> <ul> <li><code>type_id</code> - The type of items to reconcile against per the API specification.</li> <li><code>top_res</code> - Either the number of results to return per entry or the string 'all' to return all results.</li> <li><code>property_mapping</code> - A list of properties to filter results on per the API specification.</li> <li><code>reconciliation_endpoint</code> - The reconciliation service to connect to.  Defaults to <code>https://wikidata.reconci.link/en/api</code>.</li> </ul>"},{"location":"#other-very-useful-packages","title":"Other very useful packages","text":"<p>Although my opinion may be biased, I think <code>reconciler</code> is a pretty nice package. But the thing is, it probably won't fulfill all your Wikidata-related needs. Here are other packages that could help with that:</p> <ul> <li> <p>WikidataIntegrator has a lot of very nice, low-level, functions      for dealing with various wikidata-related activities, such as item acquisition and programmatic editing.</p> </li> <li> <p>wikidata2df is a very simple utility package for quickly and easily     turning wikidata SPARQL queries into Pandas DataFrames.</p> </li> </ul>"},{"location":"authors/","title":"Contributors","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>Jo\u00e3o Vitor F. Cavalcante (jvfe)</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<ul> <li>gitonthescene</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jvfe/reconciler/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>reconciler could always use more documentation, whether as part of the official reconciler docs, in docstrings, or even on the web in blog posts, articles, and such. To write documentation, check out the docs/ directory, and become familiar with mkdocs - it's very easy.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jvfe/reconciler/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up reconciler for local development.</p> <ul> <li> <p>Fork the reconciler repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ul> <pre><code>$ git clone git@github.com:your_name_here/reconciler.git\n</code></pre> <ul> <li>Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:</li> </ul> <pre><code>$ mkvirtualenv reconciler\n$ cd reconciler/\n$ python setup.py develop\n</code></pre> <ul> <li>Create a branch for local development:</li> </ul> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ul> <li>When you're done making changes, check that your changes are black-formatted and pass the tests:</li> </ul> <pre><code>$ black reconciler tests\n$ python setup.py test or pytest\n$ pytest\n</code></pre> <p>To get black, just pip install it into your virtualenv.</p> <ul> <li> <p>Add your name to the docs/authors.md file.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> </li> </ul> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ul> <li>Submit a pull request through the GitHub website.</li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, if your pull request includes code changes check that it meets these guidelines:</p> <ul> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. <ul> <li>Put your new functionality into a function with a docstring, and update the docs/reference files.</li> </ul> </li> <li>Make sure your code changes were formatted with the Black styling tool.</li> </ul>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>$ pytest tests.test_reconciler\n</code></pre>"},{"location":"history/","title":"History","text":""},{"location":"history/#021-2021-05-31","title":"0.2.1 (2021-05-31)","text":"<ul> <li>Adds options section to README (#11)</li> <li>Fixes bug by handling both IndexErrors and KeyErrors on webutils.py (#11)</li> <li>Changes the name of the main module to avoid conflicts (#13)</li> </ul>"},{"location":"history/#020-2021-01-18","title":"0.2.0 (2021-01-18)","text":"<ul> <li>Various refactorings in the utilities modules to make the code better and easier to read.</li> <li>Changes the has_property argument to the property_mapping argument,  which now takes in a dictionary of property-column mappings,  instead of being a tuple of strings.<ul> <li>This is a significant improvement and something I had in mind from the start.</li> </ul> </li> </ul>"},{"location":"history/#016-2020-12-20","title":"0.1.6 (2020-12-20)","text":"<ul> <li>Minor styling fixes, start using isort.</li> </ul>"},{"location":"history/#015-2020-10-27","title":"0.1.5 (2020-10-27)","text":"<ul> <li>Fixes bug on reconciler.reconcile when parsing empty results.</li> </ul>"},{"location":"history/#014-2020-10-14","title":"0.1.4 (2020-10-14)","text":"<ul> <li>Makes the type_id argument optional, to allow reconciliation against any term.</li> </ul>"},{"location":"history/#013-2020-09-26","title":"0.1.3 (2020-09-26)","text":"<ul> <li>Adds a new argument to the main function, has_property, which allows to reconcile against specific property-value pairs.</li> </ul>"},{"location":"history/#012-2020-09-24","title":"0.1.2 (2020-09-24)","text":"<ul> <li> <p>Dataframes with more than 10 rows are now split in multiple dataframes, to avoid timeouts due to large requests.</p> </li> <li> <p>Adds a tqdm progress bar for the reconciliation.</p> </li> </ul>"},{"location":"history/#011-2020-09-04","title":"0.1.1 (2020-09-04)","text":"<ul> <li>Adds reconciliation_endpoint argument, so the user can define the service (Defaults to Wikidata)</li> <li>Changes qid_type argument to be called type_id.</li> </ul>"},{"location":"history/#010-2020-08-30","title":"0.1.0 (2020-08-30)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installing/","title":"Installation","text":""},{"location":"installing/#stable-release","title":"Stable release","text":"<p>To install reconciler, run this command in your terminal:</p> <pre><code>$ pip install reconciler\n</code></pre> <p>This is the preferred method to install reconciler, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installing/#from-sources","title":"From sources","text":"<p>The sources for reconciler can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/jvfe/reconciler\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/jvfe/reconciler/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ python setup.py install\n</code></pre>"},{"location":"examples/reconcile_cell_types/","title":"Reconciling cell types","text":"<p>In this showcase we'll try to reconcile some cell-type data from the Tabula muris dataset.</p> <p>First off, let's load the necessary packages and read in the data using Pandas. For speed and simplicity, I'll only be reconciling the unique tissue/cell_ontology_class pairs. </p>"},{"location":"examples/reconcile_cell_types/#pre-processing","title":"Pre-processing","text":"<pre><code>from reconciler import reconcile\nimport pandas as pd\n\ndata_url = \"https://s3-eu-west-1.amazonaws.com/pfigshare-u-files/10039264/annotations_droplets.csv\"\n\ncell_table = pd.read_csv(data_url)\ncell_table.head()\n</code></pre> cell tissue cell_ontology_class cell_ontology_term_iri cell_ontology_id 10X_P4_3_AAAGTAGAGATGCCAG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACCGCGTCCAACCAA Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCCCGTCGGGTCT Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 10X_P4_3_AACTCTTAGTTGCAGG Bladder bladder cell http://purl.obolibrary.org/obo/CL_1001319 CL:1001319 10X_P4_3_AACTCTTTCATAACCG Bladder mesenchymal cell http://purl.obolibrary.org/obo/CL_0008019 CL:0008019 <p>Filtering only the unique pairs:</p> <pre><code>unique_cells = cell_table.drop_duplicates(subset=['tissue', 'cell_ontology_class'])\n</code></pre>"},{"location":"examples/reconcile_cell_types/#reconciliation","title":"Reconciliation","text":"<p>Reconciling, against cell type (Q189118), returning the first 2 matches for each item:</p> <p>This step will take a while to complete, varying according to your upload speed, here it took around a minute.</p> <pre><code>reconciled = reconcile(unique_cells['cell_ontology_class'], type_id=\"Q189118\", top_res=2)\nreconciled.head(10)\n</code></pre> <p>The output I got:</p> id match name score type type_id input_value Q1922379 True mesenchymal stem cells 100 cell type Q189118 mesenchymal cell Q66563456 False epithelial cell of gall bladder 28 [] nan bladder cell Q66568549 False urothelial cell of trigone of urinary bladder 21 [] nan bladder cell Q11394395 False endothelial cells 50 [] nan endothelial cell Q68620792 False human sinusoidal endothelial cell 32.5 [] nan endothelial cell Q66590632 False basal cell of urothelium 50 [] nan basal cell of urothelium Q66590636 False basal cell layer of urothelium 44.5 [] nan basal cell of urothelium Q223143 False granulocyte 67 cell type Q189118 leukocyte Q1775422 False agranulocyte 60 cell type Q189118 leukocyte Q463418 True fibroblast 100 cell type Q189118 fibroblast <p>Now if you look at the object, you will see the matches retrieved for each item.</p> <p>Interestingly, as of 30 Aug. 2020, there's not a lot of cell type data present in Wikidata,  a lot of the matches didn't even return a \"type\" value! That means they don't even have an  'instance of' property. This could be very interesting to look into, and add this information.</p>"},{"location":"reference/reconcile/","title":"reconciler.main","text":"<p>The main module, containing the functions intended for end-users.</p> <p>reconcile()</p> <p>Reconcile a DataFrame column</p> <p>This is the main function of this package, it takes in a Pandas Series, that is, a column of a DataFrame, and sends it for reconciliation. In order to return more confident results, the parameter type_id corresponds to the type of item you're trying to reconcile against, that is, in case of a Wikidata item, it is the item's 'instance of' property. There is also a top_res argument, to filter the retrieved matches, this can be either an int, corresponding to the number of matches you want to retrieve for each reconciled item, or 'all', to return all matches. The property_mapping argument is an optional argument to denote particular triples to reconcile against, so you could, for example, reconcile against items of a particular type, that have a specific property equals to some specific value. The reconciliation_endpoint argument corresponds to the reconciliation service you're trying to access, if no value is given, it will default to the Wikidata reconciliation endpoint. See https://reconciliation-api.github.io/testbench/ for a list of available endpoints.</p> <p>Parameters:</p> Name Type Description Default <code>column_to_reconcile</code> <code>Series</code> <p>A pandas Series corresponding to the column to be reconciled.</p> required <code>type_id</code> <code>str</code> <p>The item type to reconcile against, in case of a wikidata item, it corresponds to the item's 'instance of' QID.</p> <code>None</code> <code>top_res</code> <code>int or str</code> <p>The maximum number of matches to return for each reconciled item, defaults to one. To retrieve all matches, set it to 'all'.</p> <code>1</code> <code>property_mapping</code> <code>dict</code> <p>Property-column mapping of the items you want to reconcile against. For example, {\"P17\": df['country']} to reconcile against items that have the property country equals to the values in the column country. This is optional and defaults to None.</p> <code>None</code> <code>reconciliation_endpoint</code> <code>str</code> <p>The reconciliation endpoint, defaults to the Wikidata reconciliation endpoint.</p> <code>'https://wikidata.reconci.link/en/api'</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A Pandas DataFrame with the reconciled results.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>top_res argument must be one of either 'all' or an integer.</p> Source code in <code>reconciler/main.py</code> <pre><code>def reconcile(\n    column_to_reconcile,\n    type_id=None,\n    top_res=1,\n    property_mapping=None,\n    reconciliation_endpoint=\"https://wikidata.reconci.link/en/api\",\n):\n\"\"\"\n    Reconcile a DataFrame column\n\n    This is the main function of this package, it takes in a Pandas Series,\n    that is, a column of a DataFrame, and sends it for reconciliation. In\n    order to return more confident results, the parameter type_id corresponds\n    to the type of item you're trying to reconcile against, that is, in case of a Wikidata item,\n    it is the item's 'instance of' property. There is also a top_res argument,\n    to filter the retrieved matches, this can be either an int, corresponding to the number of\n    matches you want to retrieve for each reconciled item, or 'all', to return all matches.\n    The property_mapping argument is an optional argument to denote particular triples to reconcile\n    against, so you could, for example, reconcile against items of a particular type, that have\n    a specific property equals to some specific value. The reconciliation_endpoint argument corresponds\n    to the reconciliation service you're trying to access, if no value is given, it will default to\n    the Wikidata reconciliation endpoint. See &lt;https://reconciliation-api.github.io/testbench/&gt; for a\n    list of available endpoints.\n\n    Args:\n        column_to_reconcile (Series): A pandas Series corresponding to\n            the column to be reconciled.\n        type_id (str): The item type to reconcile against, in case of a\n            wikidata item, it corresponds to the item's 'instance of' QID.\n        top_res (int or str): The maximum number of matches to return for\n            each reconciled item, defaults to one. To retrieve all matches,\n            set it to 'all'.\n        property_mapping (dict): Property-column mapping of the items you want to\n            reconcile against. For example, {\"P17\": df['country']} to reconcile\n            against items that have the property country equals to the values\n            in the column country. This is optional and defaults to None.\n        reconciliation_endpoint (str): The reconciliation endpoint, defaults\n            to the Wikidata reconciliation endpoint.\n\n    Returns:\n        DataFrame: A Pandas DataFrame with the reconciled results.\n\n    Raises:\n        ValueError: top_res argument must be one of either 'all' or an integer.\n    \"\"\"\n\n    input_keys, response = return_reconciled_raw(\n        column_to_reconcile,\n        type_id,\n        property_mapping,\n        reconciliation_endpoint,\n    )\n\n    full_df = parse_raw_results(input_keys, response)\n\n    if top_res == \"all\":\n        return full_df\n    elif isinstance(top_res, int):\n        filtered = full_df.groupby(\"input_value\").head(top_res).reset_index(drop=True)\n        return filtered\n    else:\n        raise ValueError(\"top_res argument must be one of either 'all' or an integer\")\n</code></pre>"},{"location":"reference/utils/","title":"reconciler.utils","text":"<p>get_query_dict()</p> <p>Convert a pandas DataFrame column to a query dictionary</p> <p>The reconciliation API requires a json request formatted in a very particular way. This function takes in a DataFrame column and reformats it.</p> <p>Parameters:</p> Name Type Description Default <code>df_column</code> <code>Series</code> <p>A pandas Series to reconcile.</p> required <code>type_id</code> <code>str</code> <p>A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item.</p> required <code>property_mapping</code> <code>dict</code> <p>Property-column mapping of the items you want to reconcile against. For example, {\"P17\": df['country']} to reconcile against items that have the property country equals to the values in the column country. This is optional and defaults to None.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the list of the original values sent to reconciliation a dictionary with the column values reformatted.</p> Source code in <code>reconciler/utils.py</code> <pre><code>def get_query_dict(df_column, type_id, property_mapping):\n\"\"\"\n    Convert a pandas DataFrame column to a query dictionary\n\n    The reconciliation API requires a json request formatted in a\n    very particular way. This function takes in a DataFrame column\n    and reformats it.\n\n    Args:\n        df_column (Series): A pandas Series to reconcile.\n        type_id (str): A string specifying the item type to reconcile against,\n            in Wikidata this corresponds to the 'instance of' property of an item.\n        property_mapping (dict): Property-column mapping of the items you want to\n            reconcile against. For example, {\"P17\": df['country']} to reconcile\n            against items that have the property country equals to the values\n            in the column country. This is optional and defaults to None.\n    Returns:\n        tuple: A tuple containing the list of the original values\n            sent to reconciliation a dictionary with the\n            column values reformatted.\n    \"\"\"\n    input_keys = df_column.unique()\n    reformatted = defaultdict(dict)\n\n    for idx, value in enumerate(input_keys):\n\n        reformatted[idx][\"query\"] = value\n\n        if type_id is not None:\n            reformatted[idx][\"type\"] = type_id\n        if property_mapping is not None:\n            reformatted[idx][\"properties\"] = create_property_array(\n                df_column, property_mapping, value\n            )\n\n    return input_keys, reformatted\n</code></pre> <p>create_property_array()</p> <p>Create a query JSON 'properties' array</p> <p>Creates the properties array necessary for when the property_mapping is defined.</p> <p>Parameters:</p> Name Type Description Default <code>df_column</code> <code>Series</code> <p>A pandas Series to reconcile.</p> required <code>property_mapping</code> <code>dict</code> <p>The property-column mapping dictionary.</p> required <code>current_value</code> <code>str</code> <p>Current iteration through the input_keys</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries corresponding to the properties.</p> Source code in <code>reconciler/utils.py</code> <pre><code>def create_property_array(df_column, property_mapping, current_value):\n\"\"\"\n    Create a query JSON 'properties' array\n\n    Creates the properties array necessary for when the property_mapping is defined.\n\n    Args:\n        df_column (Series): A pandas Series to reconcile.\n        property_mapping (dict): The property-column mapping dictionary.\n        current_value (str): Current iteration through the input_keys\n\n    Returns:\n        list: A list of dictionaries corresponding to the properties.\n    \"\"\"\n\n    prop_mapping_list = []\n    for key, value in property_mapping.items():\n\n        prop_value = (\n            value.loc[df_column == current_value].to_string(index=False).strip()\n        )\n\n        prop_mapping_list.append({\"pid\": key, \"v\": prop_value})\n\n    return prop_mapping_list\n</code></pre> <p>chunk_dictionary()</p> <p>Split a large dictionary into equal-sized dictionaries</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary to be split.</p> required <code>size</code> <code>int</code> <p>The size the smaller dictionaries are supposed to be.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A subdivision of the larger dictionary, of the corresponding size.</p> Source code in <code>reconciler/utils.py</code> <pre><code>def chunk_dictionary(data, size=10):\n\"\"\"\n    Split a large dictionary into equal-sized dictionaries\n\n    Args:\n        data (dict): The dictionary to be split.\n        size (int): The size the smaller dictionaries are supposed to be.\n\n    Returns:\n        dict: A subdivision of the larger dictionary, of the\n            corresponding size.\n    \"\"\"\n    # https://stackoverflow.com/questions/22878743/how-to-split-dictionary-into-multiple-dictionaries-fast\n    it = iter(data)\n    for _ in range(0, len(data), size):\n        yield {k: data[k] for k in islice(it, size)}\n</code></pre>"},{"location":"reference/webutils/","title":"reconciler.webutils","text":"<p>The web utilities module, for performing and parsing queries.</p> <p>perform_query()</p> <p>Make a post request to the reconciliation API</p> <p>Parameters:</p> Name Type Description Default <code>query_string</code> <code>str</code> <p>A string corresponding to the query JSON.</p> required <code>reconciliation_endpoint</code> <code>str</code> <p>A url to the reconciliation endpoint.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary (JSON) with the query results.</p> <p>Raises:</p> Type Description <code>requests.HTTPError</code> <p>The query returned an error, check if you mistyped an argument.</p> <code>requests.ConnectionError</code> <p>Couldn't connect to reconciliation client.</p> Source code in <code>reconciler/webutils.py</code> <pre><code>@lru_cache(maxsize=None)\ndef perform_query(query_string, reconciliation_endpoint, max_tries=10):\n\"\"\"Make a post request to the reconciliation API\n\n    Args:\n        query_string (str): A string corresponding to the query JSON.\n        reconciliation_endpoint (str): A url to the reconciliation endpoint.\n\n    Returns:\n        dict: A dictionary (JSON) with the query results.\n\n    Raises:\n        requests.HTTPError: The query returned an error, check if you mistyped an argument.\n        requests.ConnectionError: Couldn't connect to reconciliation client.\n\n    \"\"\"\n\n    tries = 0\n    while tries &lt; max_tries:\n        try:\n            response = http.post(\n                reconciliation_endpoint, data=json.loads(query_string)\n            )\n            # HTTP Service Unavailable\n            if response.status_code == 503:\n                tries += 1 \n                continue\n        except requests.ConnectionError:\n            tries += 1\n        else:\n            query_result = response.json()\n            if \"status\" in query_result and query_result[\"status\"] == \"error\":\n                raise requests.HTTPError(\n                    \"The query returned an error, check if you mistyped an argument.\"\n                )\n            else:\n                return query_result\n        logger.warn('Encountered an error trying again (tries=%s)', tries)\n    if tries == max_tries:\n        logger.warn('Too many errors (%s) while talking to reconcilitation server', max_tries)\n        raise requests.ConnectionError(\"Couldn't connect to reconciliation server\")\n</code></pre> <p>return_reconciled_raw()</p> <p>Send reformatted dict for reconciliation</p> <p>This is just a wrapper around the other utility functions. The only thing it actually does is convert the query dict to an appropriate JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>df_column</code> <code>Series</code> <p>A pandas Series to reconcile.</p> required <code>type_id</code> <code>str</code> <p>A string specifying the item type to reconcile against, in Wikidata this corresponds to the 'instance of' property of an item.</p> required <code>property_mapping</code> <code>dict</code> <p>Property-column mapping of the items you want to reconcile against. For example, {\"P17\": df['country']} to reconcile against items that have the property country equals to the values in the column country. This is optional and defaults to None.</p> required <code>reconciliation_endpoint</code> <code>str</code> <p>A url to the reconciliation endpoint.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the list of the original values sent to reconciliation and a dictionary (JSON) with the query results.</p> Source code in <code>reconciler/webutils.py</code> <pre><code>def return_reconciled_raw(\n    df_column, type_id, property_mapping, reconciliation_endpoint\n):\n\"\"\"Send reformatted dict for reconciliation\n\n    This is just a wrapper around the other utility functions. The\n    only thing it actually does is convert the query dict to an\n    appropriate JSON string.\n\n    Args:\n        df_column (Series): A pandas Series to reconcile.\n        type_id (str): A string specifying the item type to reconcile against,\n            in Wikidata this corresponds to the 'instance of' property of an item.\n        property_mapping (dict): Property-column mapping of the items you want to\n            reconcile against. For example, {\"P17\": df['country']} to reconcile\n            against items that have the property country equals to the values\n            in the column country. This is optional and defaults to None.\n        reconciliation_endpoint (str): A url to the reconciliation endpoint.\n\n    Returns:\n        tuple: A tuple containing the list of the original values\n            sent to reconciliation and a dictionary (JSON)\n            with the query results.\n\n    \"\"\"\n\n    input_keys, reformatted = get_query_dict(df_column, type_id, property_mapping)\n\n    query_results = []\n    chunked_dict = list(chunk_dictionary(reformatted))\n\n    for chunk in tqdm(chunked_dict, position=0, leave=True):\n        logger.debug('reconciling: %s', chunk)\n        reconcilable_data = json.dumps({\"queries\": json.dumps(chunk)})\n        query_result = perform_query(reconcilable_data, reconciliation_endpoint)\n        query_results.append(query_result)\n\n    merged_results = dict(ChainMap(*query_results))\n\n    return input_keys, merged_results\n</code></pre> <p>parse_raw_results()</p> <p>Parse JSON query result</p> <p>Parameters:</p> Name Type Description Default <code>input_keys</code> <code>list</code> <p>A list with the original input values that were used to reconcile.</p> required <code>response</code> <code>dict</code> <p>A dict corresponding to the raw JSON response from the reconciliation API.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A Pandas DataFrame with all the results.</p> Source code in <code>reconciler/webutils.py</code> <pre><code>def parse_raw_results(input_keys, response):\n\"\"\"\n    Parse JSON query result\n\n    Args:\n        input_keys (list): A list with the original input values\n            that were used to reconcile.\n        response (dict): A dict corresponding to the raw JSON response\n            from the reconciliation API.\n\n    Returns:\n        DataFrame: A Pandas DataFrame with all the results.\n    \"\"\"\n\n    res_keys = sorted(response.keys(), key=int)\n\n    dfs = []\n    for idx, key in enumerate(res_keys):\n\n        current_df = pd.json_normalize(response[key][\"result\"])\n\n        if current_df.empty:\n            current_df = pd.DataFrame(\n                {\n                    \"id\": [np.NaN],\n                    \"match\": [False],\n                }\n            )\n        else:\n            try:\n                current_df.drop([\"features\"], axis=1, inplace=True)\n                current_df[\"type_id\"] = [item[0][\"id\"] for item in current_df[\"type\"]]\n                current_df[\"type\"] = [item[0][\"name\"] for item in current_df[\"type\"]]\n            except (IndexError, KeyError):\n                pass\n\n        current_df[\"input_value\"] = input_keys[idx]\n        dfs.append(current_df)\n\n    concatenated = pd.concat(dfs)\n\n    return concatenated\n</code></pre>"}]}